<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<title>NATS C Client with JetStream and Streaming support: Callbacks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;" >
   <div id="projectname">NATS C Client with JetStream and Streaming support
   &#160;<span id="projectnumber">3.7.0</span>
   </div>
   <div id="projectbrief">The nats.io C Client, Supported by Synadia Communications Inc.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__callbacks_group.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle"><div class="title">Callbacks</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad1a5ac566893e13dc8c81ac0e9c87afe" id="r_gad1a5ac566893e13dc8c81ac0e9c87afe"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gad1a5ac566893e13dc8c81ac0e9c87afe">natsMsgHandler</a>) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, <a class="el" href="group__types_group.html#ga87158ec63b4f90f69e20451624ea01d8">natsSubscription</a> *sub, <a class="el" href="group__types_group.html#gadcab54026c4ed78f344ce03ce31bb61a">natsMsg</a> *msg, void *closure)</td></tr>
<tr class="memdesc:gad1a5ac566893e13dc8c81ac0e9c87afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to deliver messages to the application.  <br /></td></tr>
<tr class="separator:gad1a5ac566893e13dc8c81ac0e9c87afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdef6aff3e47953f19e35857ab8e274c" id="r_gacdef6aff3e47953f19e35857ab8e274c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gacdef6aff3e47953f19e35857ab8e274c">natsConnectionHandler</a>) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, void *closure)</td></tr>
<tr class="memdesc:gacdef6aff3e47953f19e35857ab8e274c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify the user of asynchronous connection events.  <br /></td></tr>
<tr class="separator:gacdef6aff3e47953f19e35857ab8e274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e511dffa471dfb971b7dd2b12329626" id="r_ga9e511dffa471dfb971b7dd2b12329626"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga9e511dffa471dfb971b7dd2b12329626">natsErrHandler</a>) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, <a class="el" href="group__types_group.html#ga87158ec63b4f90f69e20451624ea01d8">natsSubscription</a> *subscription, <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a> err, void *closure)</td></tr>
<tr class="memdesc:ga9e511dffa471dfb971b7dd2b12329626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify the user of errors encountered while processing inbound messages.  <br /></td></tr>
<tr class="separator:ga9e511dffa471dfb971b7dd2b12329626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245eab0a01a485e40fba267f84ec037f" id="r_ga245eab0a01a485e40fba267f84ec037f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga245eab0a01a485e40fba267f84ec037f">natsEvLoop_Attach</a>) (void **userData, void *loop, <a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, <a class="el" href="nats_8h.html#af798865ac824e5959987de0fe8d07383">natsSock</a> socket)</td></tr>
<tr class="memdesc:ga245eab0a01a485e40fba267f84ec037f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach this connection to the external event loop.  <br /></td></tr>
<tr class="separator:ga245eab0a01a485e40fba267f84ec037f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4c125ecfb43eaf43da20e8444c2aaa" id="r_gaea4c125ecfb43eaf43da20e8444c2aaa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gaea4c125ecfb43eaf43da20e8444c2aaa">natsEvLoop_ReadAddRemove</a>) (void *userData, bool add)</td></tr>
<tr class="memdesc:gaea4c125ecfb43eaf43da20e8444c2aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read event needs to be added or removed.  <br /></td></tr>
<tr class="separator:gaea4c125ecfb43eaf43da20e8444c2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb5dd2d821ca5bbc0488f7e6aceed17" id="r_ga2bb5dd2d821ca5bbc0488f7e6aceed17"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga2bb5dd2d821ca5bbc0488f7e6aceed17">natsEvLoop_WriteAddRemove</a>) (void *userData, bool add)</td></tr>
<tr class="memdesc:ga2bb5dd2d821ca5bbc0488f7e6aceed17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write event needs to be added or removed.  <br /></td></tr>
<tr class="separator:ga2bb5dd2d821ca5bbc0488f7e6aceed17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63dee7f7012ba11ae20b76dbc36f2d0" id="r_gab63dee7f7012ba11ae20b76dbc36f2d0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gab63dee7f7012ba11ae20b76dbc36f2d0">natsEvLoop_Detach</a>) (void *userData)</td></tr>
<tr class="memdesc:gab63dee7f7012ba11ae20b76dbc36f2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach from the event loop.  <br /></td></tr>
<tr class="separator:gab63dee7f7012ba11ae20b76dbc36f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258b30458134be90f17315c037f34b7b" id="r_ga258b30458134be90f17315c037f34b7b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga258b30458134be90f17315c037f34b7b">natsUserJWTHandler</a>) (char **userJWT, char **customErrTxt, void *closure)</td></tr>
<tr class="memdesc:ga258b30458134be90f17315c037f34b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to fetch and return account signed user JWT.  <br /></td></tr>
<tr class="separator:ga258b30458134be90f17315c037f34b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab786ffd670c86de0563559351305080b" id="r_gab786ffd670c86de0563559351305080b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gab786ffd670c86de0563559351305080b">natsSignatureHandler</a>) (char **customErrTxt, unsigned char **signature, int *signatureLength, const char *nonce, void *closure)</td></tr>
<tr class="memdesc:gab786ffd670c86de0563559351305080b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to sign a nonce sent by the server.  <br /></td></tr>
<tr class="separator:gab786ffd670c86de0563559351305080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b02de70fe9380d184fd01d87527f499" id="r_ga4b02de70fe9380d184fd01d87527f499"><td class="memItemLeft" align="right" valign="top">typedef const char *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga4b02de70fe9380d184fd01d87527f499">natsTokenHandler</a>) (void *closure)</td></tr>
<tr class="memdesc:ga4b02de70fe9380d184fd01d87527f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to build a token on connections and reconnections.  <br /></td></tr>
<tr class="separator:ga4b02de70fe9380d184fd01d87527f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245131e64f1d0dff7edc8ed874a07e9a" id="r_ga245131e64f1d0dff7edc8ed874a07e9a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga245131e64f1d0dff7edc8ed874a07e9a">natsOnCompleteCB</a>) (void *closure)</td></tr>
<tr class="memdesc:ga245131e64f1d0dff7edc8ed874a07e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify that an object lifecycle is complete.  <br /></td></tr>
<tr class="separator:ga245131e64f1d0dff7edc8ed874a07e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3353d4b92851c52121f65aaf0684cba4" id="r_ga3353d4b92851c52121f65aaf0684cba4"><td class="memItemLeft" align="right" valign="top">typedef int64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga3353d4b92851c52121f65aaf0684cba4">natsCustomReconnectDelayHandler</a>) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, int attempts, void *closure)</td></tr>
<tr class="memdesc:ga3353d4b92851c52121f65aaf0684cba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to specify how long to wait between reconnects.  <br /></td></tr>
<tr class="separator:ga3353d4b92851c52121f65aaf0684cba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga954768cc1d3388bb6ab723e777647992" id="r_ga954768cc1d3388bb6ab723e777647992"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga954768cc1d3388bb6ab723e777647992">jsPubAckErrHandler</a>) (<a class="el" href="group__types_group.html#gaaf12cdd24c6cc23a57c20466c92ff8c1">jsCtx</a> *js, <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> *pae, void *closure)</td></tr>
<tr class="memdesc:ga954768cc1d3388bb6ab723e777647992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to process asynchronous publish errors from JetStream.  <br /></td></tr>
<tr class="separator:ga954768cc1d3388bb6ab723e777647992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f66e065bd918f02510d4c53d8a5b729" id="r_ga4f66e065bd918f02510d4c53d8a5b729"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#ga4f66e065bd918f02510d4c53d8a5b729">jsPubAckHandler</a>) (<a class="el" href="group__types_group.html#gaaf12cdd24c6cc23a57c20466c92ff8c1">jsCtx</a> *js, <a class="el" href="group__types_group.html#gadcab54026c4ed78f344ce03ce31bb61a">natsMsg</a> *msg, <a class="el" href="structjs_pub_ack.html">jsPubAck</a> *pa, <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> *pae, void *closure)</td></tr>
<tr class="memdesc:ga4f66e065bd918f02510d4c53d8a5b729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to process asynchronous publish responses from JetStream.  <br /></td></tr>
<tr class="separator:ga4f66e065bd918f02510d4c53d8a5b729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5d6a685731b3bf635995b7375af4d18" id="r_gad5d6a685731b3bf635995b7375af4d18"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gad5d6a685731b3bf635995b7375af4d18">stanPubAckHandler</a>) (const char *guid, const char *error, void *closure)</td></tr>
<tr class="memdesc:gad5d6a685731b3bf635995b7375af4d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify of an asynchronous publish result.  <br /></td></tr>
<tr class="separator:gad5d6a685731b3bf635995b7375af4d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7456e37fa14f1834d9048d3789e9409" id="r_gaf7456e37fa14f1834d9048d3789e9409"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gaf7456e37fa14f1834d9048d3789e9409">stanMsgHandler</a>) (<a class="el" href="group__types_group.html#ga9e826493769d23086cfccefe95cdf64c">stanConnection</a> *sc, <a class="el" href="group__types_group.html#gae4dae869fb614536f0f027c2e2660cc5">stanSubscription</a> *sub, const char *channel, <a class="el" href="group__types_group.html#ga2cf5db7703b42d97abe56a3e83b2a87d">stanMsg</a> *msg, void *closure)</td></tr>
<tr class="memdesc:gaf7456e37fa14f1834d9048d3789e9409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to deliver messages to the application.  <br /></td></tr>
<tr class="separator:gaf7456e37fa14f1834d9048d3789e9409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34092f6c698374f86ad349302bdd55c" id="r_gac34092f6c698374f86ad349302bdd55c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__callbacks_group.html#gac34092f6c698374f86ad349302bdd55c">stanConnectionLostHandler</a>) (<a class="el" href="group__types_group.html#ga9e826493769d23086cfccefe95cdf64c">stanConnection</a> *sc, const char *errorTxt, void *closure)</td></tr>
<tr class="memdesc:gac34092f6c698374f86ad349302bdd55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify the user of the permanent loss of the connection.  <br /></td></tr>
<tr class="separator:gac34092f6c698374f86ad349302bdd55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>NATS Callbacks. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad1a5ac566893e13dc8c81ac0e9c87afe" name="gad1a5ac566893e13dc8c81ac0e9c87afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1a5ac566893e13dc8c81ac0e9c87afe">&#9670;&#160;</a></span>natsMsgHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* natsMsgHandler) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, <a class="el" href="group__types_group.html#ga87158ec63b4f90f69e20451624ea01d8">natsSubscription</a> *sub, <a class="el" href="group__types_group.html#gadcab54026c4ed78f344ce03ce31bb61a">natsMsg</a> *msg, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the callback that one provides when creating an asynchronous subscription. The library will invoke this callback for each message arriving through the subscription's connection.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this callback is setup for a subject that is used as the reply subject to <a class="el" href="group__conn_pub_group.html#gaaaa3d75ffec2dcdc6bf905cdb1eee59e" title="Publishes data on a subject expecting replies on the given reply.">natsConnection_PublishRequest</a> calls (and its variants), it is possible to get an empty message with a header "Status" with value "503" that is sent by the server when there were no responders on the request's subject. Use <a class="el" href="group__msg_group.html#ga43aa4a8e4b93725b4876ee2677e19c7b" title="Indicates if this message is a &quot;no responders&quot; message from the server.">natsMsg_IsNoResponders</a> to know if that is the case.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__conn_sub_group.html#gaefab965b5645798d47f9244f2b3fe3fb" title="Creates an asynchronous subscription.">natsConnection_Subscribe()</a> </dd>
<dd>
<a class="el" href="group__conn_sub_group.html#ga3c9fee2775130786ef62f1cbeb191a48" title="Creates an asynchronous queue subscriber.">natsConnection_QueueSubscribe()</a> </dd>
<dd>
<a class="el" href="group__msg_group.html#ga43aa4a8e4b93725b4876ee2677e19c7b" title="Indicates if this message is a &quot;no responders&quot; message from the server.">natsMsg_IsNoResponders()</a> </dd></dl>

</div>
</div>
<a id="gacdef6aff3e47953f19e35857ab8e274c" name="gacdef6aff3e47953f19e35857ab8e274c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdef6aff3e47953f19e35857ab8e274c">&#9670;&#160;</a></span>natsConnectionHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* natsConnectionHandler) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback is used for asynchronous events such as disconnected and closed connections.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opts_group.html#ga44410242e73134e5bb51ef27904a9253" title="Sets the callback to be invoked when a connection to a server is permanently lost.">natsOptions_SetClosedCB()</a> </dd>
<dd>
<a class="el" href="group__opts_group.html#gadc8dc0cedd91bda71d544f3dedc4a039" title="Sets the callback to be invoked when the connection to a server is lost.">natsOptions_SetDisconnectedCB()</a> </dd>
<dd>
<a class="el" href="group__opts_group.html#ga26a48c8529fffa5f5d1a61c030979980" title="Sets the callback to be invoked when the connection has reconnected.">natsOptions_SetReconnectedCB()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Such callback is invoked from a dedicated thread and the state of the connection that triggered the event may have changed since that event was generated. </dd></dl>

</div>
</div>
<a id="ga9e511dffa471dfb971b7dd2b12329626" name="ga9e511dffa471dfb971b7dd2b12329626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e511dffa471dfb971b7dd2b12329626">&#9670;&#160;</a></span>natsErrHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* natsErrHandler) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, <a class="el" href="group__types_group.html#ga87158ec63b4f90f69e20451624ea01d8">natsSubscription</a> *subscription, <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a> err, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback is used to process asynchronous errors encountered while processing inbound messages, such as <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80ae93ff5b7fe31f8570308385d92d317b0">NATS_SLOW_CONSUMER</a>. </p>

</div>
</div>
<a id="ga245eab0a01a485e40fba267f84ec037f" name="ga245eab0a01a485e40fba267f84ec037f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245eab0a01a485e40fba267f84ec037f">&#9670;&#160;</a></span>natsEvLoop_Attach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(* natsEvLoop_Attach) (void **userData, void *loop, <a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, <a class="el" href="nats_8h.html#af798865ac824e5959987de0fe8d07383">natsSock</a> socket)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After a connection has (re)connected, this callback is invoked. It should perform the necessary work to start polling the given socket for READ events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>location where the adapter implementation will store the object it created and that will later be passed to all other callbacks. If <code>*userData</code> is not <code>NULL</code>, this means that this is a reconnect event. </td></tr>
    <tr><td class="paramname">loop</td><td>the event loop (as a generic void*) this connection is being attached to. </td></tr>
    <tr><td class="paramname">nc</td><td>the connection being attached to the event loop. </td></tr>
    <tr><td class="paramname">socket</td><td>the socket to poll for read/write events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea4c125ecfb43eaf43da20e8444c2aaa" name="gaea4c125ecfb43eaf43da20e8444c2aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea4c125ecfb43eaf43da20e8444c2aaa">&#9670;&#160;</a></span>natsEvLoop_ReadAddRemove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(* natsEvLoop_ReadAddRemove) (void *userData, bool add)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>NATS</code> library will invoke this callback to indicate if the event loop should start (<code>add is</code>true<code>) or stop (</code>add<code>is</code>false`) polling for read events on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>the pointer to an user object created in <a class="el" href="group__callbacks_group.html#ga245eab0a01a485e40fba267f84ec037f" title="Attach this connection to the external event loop.">natsEvLoop_Attach</a>. </td></tr>
    <tr><td class="paramname">add</td><td><code>true</code> if the event library should start polling, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bb5dd2d821ca5bbc0488f7e6aceed17" name="ga2bb5dd2d821ca5bbc0488f7e6aceed17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb5dd2d821ca5bbc0488f7e6aceed17">&#9670;&#160;</a></span>natsEvLoop_WriteAddRemove</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(* natsEvLoop_WriteAddRemove) (void *userData, bool add)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>NATS</code> library will invoke this callback to indicate if the event loop should start (<code>add is</code>true<code>) or stop (</code>add<code>is</code>false`) polling for write events on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>the pointer to an user object created in <a class="el" href="group__callbacks_group.html#ga245eab0a01a485e40fba267f84ec037f" title="Attach this connection to the external event loop.">natsEvLoop_Attach</a>. </td></tr>
    <tr><td class="paramname">add</td><td><code>true</code> if the event library should start polling, <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab63dee7f7012ba11ae20b76dbc36f2d0" name="gab63dee7f7012ba11ae20b76dbc36f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab63dee7f7012ba11ae20b76dbc36f2d0">&#9670;&#160;</a></span>natsEvLoop_Detach</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(* natsEvLoop_Detach) (void *userData)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <code>NATS</code> library will invoke this callback to indicate that the connection no longer needs to be attached to the event loop. User can cleanup some state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userData</td><td>the pointer to an user object created in <a class="el" href="group__callbacks_group.html#ga245eab0a01a485e40fba267f84ec037f" title="Attach this connection to the external event loop.">natsEvLoop_Attach</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga258b30458134be90f17315c037f34b7b" name="ga258b30458134be90f17315c037f34b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258b30458134be90f17315c037f34b7b">&#9670;&#160;</a></span>natsUserJWTHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(* natsUserJWTHandler) (char **userJWT, char **customErrTxt, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler is invoked when connecting and reconnecting. It should return the user JWT that will be sent to the server.</p>
<p>The user JWT is returned as a string that is allocated by the user and is freed by the library after the handler is invoked.</p>
<p>If the user is unable to return the JWT, a status other than <code>NATS_OK</code> should be returned (we recommend <code>NATS_ERR</code>). A custom error message can be returned through <code>customErrTxt</code>. The user must allocate the memory for this error message and the library will free it after the invocation of the handler.</p>
<dl class="section warning"><dt>Warning</dt><dd>There may be repeated invocations of this handler for a given connection so it is crucial to always return a copy of the user JWT maintained by the application, since again, the library will free the memory pointed by <code>userJWT</code> after each invocation of this handler.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opts_group.html#ga60117450fc1f7b6f81bab455aeed7515" title="Sets the callbacks to fetch user JWT and sign server&#39;s nonce.">natsOptions_SetUserCredentialsCallbacks()</a> </dd>
<dd>
<a class="el" href="group__opts_group.html#ga59b47f7b7a19085cf8eaada9bfe5606e" title="Sets the file(s) to use to fetch user JWT and seed required to sign nonce.">natsOptions_SetUserCredentialsFromFiles()</a> </dd></dl>

</div>
</div>
<a id="gab786ffd670c86de0563559351305080b" name="gab786ffd670c86de0563559351305080b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab786ffd670c86de0563559351305080b">&#9670;&#160;</a></span>natsSignatureHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="status_8h.html#a36c934157b663b7b5fb5d6609c897c80">natsStatus</a>(* natsSignatureHandler) (char **customErrTxt, unsigned char **signature, int *signatureLength, const char *nonce, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This handler is invoked when connecting and reconnecting. It should sign the given <code>nonce</code> and return a raw signature through <code>signature</code> and specify how many characters the signature has using <code>signatureLength</code>.</p>
<p>The memory pointed by <code>signature</code> must be allocated by the user and will be freed by the library after each invocation of this handler.</p>
<p>If the user is unable to sign, a status other than <code>NATS_OK</code> (we recommend <code>NATS_ERR</code>) should be returned. A custom error message can be returned through <code>customErrTxt</code>. The user must allocate the memory for this error message and the library will free it after the invocation of this handler.</p>
<p>The library will base64 encode this raw signature and send that to the server.</p>
<dl class="section warning"><dt>Warning</dt><dd>There may be repeated invocations of this handler for a given connection so it is crucial to always return a copy of the signature, since again, the library will free the memory pointed by <code>signature</code> after each invocation of this handler.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opts_group.html#ga60117450fc1f7b6f81bab455aeed7515" title="Sets the callbacks to fetch user JWT and sign server&#39;s nonce.">natsOptions_SetUserCredentialsCallbacks()</a> </dd>
<dd>
<a class="el" href="group__opts_group.html#ga59b47f7b7a19085cf8eaada9bfe5606e" title="Sets the file(s) to use to fetch user JWT and seed required to sign nonce.">natsOptions_SetUserCredentialsFromFiles()</a> </dd>
<dd>
<a class="el" href="group__opts_group.html#ga0290eac4665569c850468d9f00e246a0" title="Sets the NKey public key and signature callback.">natsOptions_SetNKey()</a> </dd></dl>

</div>
</div>
<a id="ga4b02de70fe9380d184fd01d87527f499" name="ga4b02de70fe9380d184fd01d87527f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b02de70fe9380d184fd01d87527f499">&#9670;&#160;</a></span>natsTokenHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const char *(* natsTokenHandler) (void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the function that one provides to build a different token at each reconnect.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__opts_group.html#ga23a3b1f022112e98ddccb18b247b4426" title="Sets the tokenCb to use whenever a token is needed.">natsOptions_SetTokenHandler()</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Such callback is invoked synchronously from the connection thread. </dd></dl>

</div>
</div>
<a id="ga245131e64f1d0dff7edc8ed874a07e9a" name="ga245131e64f1d0dff7edc8ed874a07e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245131e64f1d0dff7edc8ed874a07e9a">&#9670;&#160;</a></span>natsOnCompleteCB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* natsOnCompleteCB) (void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Currently used for asynchronous <a class="el" href="group__types_group.html#ga87158ec63b4f90f69e20451624ea01d8" title="Interest on a given subject.">natsSubscription</a> objects. When set, this callback will be invoked after the subscription is closed and the message handler has returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__sub_group.html#gaea632f845d473e7461b134c0e7bf4077" title="Sets a completion callback.">natsSubscription_SetOnCompleteCB()</a> </dd></dl>

</div>
</div>
<a id="ga3353d4b92851c52121f65aaf0684cba4" name="ga3353d4b92851c52121f65aaf0684cba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3353d4b92851c52121f65aaf0684cba4">&#9670;&#160;</a></span>natsCustomReconnectDelayHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t(* natsCustomReconnectDelayHandler) (<a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec">natsConnection</a> *nc, int attempts, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback is used to get from the user the desired delay the library should pause before attempting to reconnect again. Note that this is invoked after the library tried the whole list of URLs and failed to reconnect.</p>
<dl class="section note"><dt>Note</dt><dd>This callback is invoked from the connection reconnect thread and waits for user input. It should not block and instead quickly return the desired reconnect delay. The state of the connection is disconnected when this callback is invoked. Not much can be done with the passed connection, but user can call <a class="el" href="group__conn_mgt_group.html#ga19e204d27a232e2d4334301fc002b2ed" title="Closes the connection.">natsConnection_Close()</a> if desired. This will abort the reconnect attempts and close the connection.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>the pointer to the <a class="el" href="group__types_group.html#gaf88dca0a18efb5c5e994d265a9f04aec" title="A connection to a NATS Server.">natsConnection</a> invoking this handler. </td></tr>
    <tr><td class="paramname">attempts</td><td>the number of times the library tried the whole list of server URLs. </td></tr>
    <tr><td class="paramname">closure</td><td>an optional pointer to a user defined object that was specified when registering the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of milliseconds to wait before trying to reconnect. </dd></dl>

</div>
</div>
<a id="ga954768cc1d3388bb6ab723e777647992" name="ga954768cc1d3388bb6ab723e777647992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga954768cc1d3388bb6ab723e777647992">&#9670;&#160;</a></span>jsPubAckErrHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* jsPubAckErrHandler) (<a class="el" href="group__types_group.html#gaaf12cdd24c6cc23a57c20466c92ff8c1">jsCtx</a> *js, <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> *pae, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback used to process asynchronous publish errors from JetStream <a class="el" href="group__js_pub_group.html#ga069dfd6f0f3d96f1ff8bf2372e59900c" title="Publishes data to JetStream but does not wait for a jsPubAck.">js_PublishAsync</a> and <a class="el" href="group__js_pub_group.html#gab7e4139a48c5ee4d2155cbb43142e873" title="Publishes a message to JetStream but does not wait for a jsPubAck.">js_PublishMsgAsync</a> calls. The provided <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> object gives the user access to the encountered error along with the original message sent to the server for possible restransmitting.</p>
<dl class="section note"><dt>Note</dt><dd>If the message is resent, the library will not destroy the original message and once again take ownership of it. To resend the message, do the following so that the library knows not to destroy the message (since the call will clear the <code>Msg</code> field from the <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> object).</dd></dl>
<div class="fragment"><div class="line">void myPAECallback(jsCtx *js, jsPubAckErr *pae, void* closure)</div>
<div class="line">{</div>
<div class="line">     ...</div>
<div class="line">     // Resend the message</div>
<div class="line">     js_PublishMsgAsync(js, &amp;(pae-&gt;Msg), NULL);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> object and its content will be invalid as soon as the callback returns.</dd>
<dd>
Unlike a NATS message callback, the user does not have to destroy the original NATS message (present in the <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> object), the library will do it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">js</td><td>the pointer to the <a class="el" href="group__types_group.html#gaaf12cdd24c6cc23a57c20466c92ff8c1">jsCtx</a> object. </td></tr>
    <tr><td class="paramname">pae</td><td>the pointer to the <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> object. </td></tr>
    <tr><td class="paramname">closure</td><td>an optional pointer to a user defined object that was specified when registering the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f66e065bd918f02510d4c53d8a5b729" name="ga4f66e065bd918f02510d4c53d8a5b729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f66e065bd918f02510d4c53d8a5b729">&#9670;&#160;</a></span>jsPubAckHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* jsPubAckHandler) (<a class="el" href="group__types_group.html#gaaf12cdd24c6cc23a57c20466c92ff8c1">jsCtx</a> *js, <a class="el" href="group__types_group.html#gadcab54026c4ed78f344ce03ce31bb61a">natsMsg</a> *msg, <a class="el" href="structjs_pub_ack.html">jsPubAck</a> *pa, <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> *pae, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback used to process asynchronous publish responses (positive and negatives) from JetStream <a class="el" href="group__js_pub_group.html#ga069dfd6f0f3d96f1ff8bf2372e59900c" title="Publishes data to JetStream but does not wait for a jsPubAck.">js_PublishAsync</a> and <a class="el" href="group__js_pub_group.html#gab7e4139a48c5ee4d2155cbb43142e873" title="Publishes a message to JetStream but does not wait for a jsPubAck.">js_PublishMsgAsync</a> calls. The provided <a class="el" href="structjs_pub_ack.html">jsPubAck</a> or <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> objects give the user access to the successful acknowledgment from the server or the encountered error along with the original message sent to the server for possible restransmitting.</p>
<dl class="section warning"><dt>Warning</dt><dd>The user is responsible for destroying the message. If the message is resent using the <a class="el" href="group__js_pub_group.html#gab7e4139a48c5ee4d2155cbb43142e873" title="Publishes a message to JetStream but does not wait for a jsPubAck.">js_PublishMsgAsync</a> call, the library is taking ownership of the message and calling <a class="el" href="group__msg_group.html#ga9e9590018284939f43f60964283f33ae" title="Destroys the message object.">natsMsg_Destroy</a> will have no effect because the pointer will have been set to <code>NULL</code>. So it is recommended to always call <a class="el" href="group__msg_group.html#ga9e9590018284939f43f60964283f33ae" title="Destroys the message object.">natsMsg_Destroy</a> at the end of the function.</dd></dl>
<div class="fragment"><div class="line">void myAckHandler(jsCtx *js, natsMsg *msg, jsPubAck *pa, jsPubAckErr *pae, void *closure)</div>
<div class="line">{</div>
<div class="line">     if (pa != NULL)</div>
<div class="line">     {</div>
<div class="line">             // Success case...</div>
<div class="line">     }</div>
<div class="line">     else if (pae != NULL)</div>
<div class="line">     {</div>
<div class="line">             // Error case...</div>
<div class="line">             // If the application wants to resend the message:</div>
<div class="line">             js_PublishMsgAsync(js, &amp;msg, NULL);</div>
<div class="line">     }</div>
<div class="line">     natsMsg_Destroy(msg);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The <a class="el" href="structjs_pub_ack.html">jsPubAck</a> and <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> objects and their content will be invalid as soon as the callback returns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">js</td><td>the pointer to the <a class="el" href="group__types_group.html#gaaf12cdd24c6cc23a57c20466c92ff8c1">jsCtx</a> object. </td></tr>
    <tr><td class="paramname">msg</td><td>the pointer to the original published <a class="el" href="group__types_group.html#gadcab54026c4ed78f344ce03ce31bb61a" title="A structure holding a subject, optional reply and payload.">natsMsg</a>. </td></tr>
    <tr><td class="paramname">pa</td><td>the pointer to the <a class="el" href="structjs_pub_ack.html">jsPubAck</a> object. </td></tr>
    <tr><td class="paramname">pae</td><td>the pointer to the <a class="el" href="structjs_pub_ack_err.html">jsPubAckErr</a> object. </td></tr>
    <tr><td class="paramname">closure</td><td>an optional pointer to a user defined object that was specified when registering the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5d6a685731b3bf635995b7375af4d18" name="gad5d6a685731b3bf635995b7375af4d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5d6a685731b3bf635995b7375af4d18">&#9670;&#160;</a></span>stanPubAckHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* stanPubAckHandler) (const char *guid, const char *error, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used for asynchronous publishing to provide status of the acknowledgment. The function will be passed the GUID and any error state. No error means the message was successfully received by NATS Streaming.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stan_conn_pub_group.html#ga0c4d1e4615f8ac834f0a4021f75d39f0" title="Asynchronously publishes data on a channel.">stanConnection_PublishAsync()</a> </dd></dl>

</div>
</div>
<a id="gaf7456e37fa14f1834d9048d3789e9409" name="gaf7456e37fa14f1834d9048d3789e9409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7456e37fa14f1834d9048d3789e9409">&#9670;&#160;</a></span>stanMsgHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* stanMsgHandler) (<a class="el" href="group__types_group.html#ga9e826493769d23086cfccefe95cdf64c">stanConnection</a> *sc, <a class="el" href="group__types_group.html#gae4dae869fb614536f0f027c2e2660cc5">stanSubscription</a> *sub, const char *channel, <a class="el" href="group__types_group.html#ga2cf5db7703b42d97abe56a3e83b2a87d">stanMsg</a> *msg, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the callback that one provides when creating an asynchronous subscription. The library will invoke this callback for each message arriving through the subscription's connection.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__stan_conn_sub_group.html#gae545358fdc493baf6d29429a8156781f" title="Creates a subscription.">stanConnection_Subscribe()</a> </dd>
<dd>
<a class="el" href="group__stan_conn_sub_group.html#ga17d42bf9a4fa39470561a1a668e6b4a2" title="Creates a queue subscription.">stanConnection_QueueSubscribe()</a> </dd></dl>

</div>
</div>
<a id="gac34092f6c698374f86ad349302bdd55c" name="gac34092f6c698374f86ad349302bdd55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac34092f6c698374f86ad349302bdd55c">&#9670;&#160;</a></span>stanConnectionLostHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* stanConnectionLostHandler) (<a class="el" href="group__types_group.html#ga9e826493769d23086cfccefe95cdf64c">stanConnection</a> *sc, const char *errorTxt, void *closure)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback is used to notify the user that the connection to the Streaming server is permanently lost. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">NATS.IO Supported By Synadia Communications Inc.
    <a href="http://www.nats.io">
    </a></li>
  </ul>
</div>
</body>
</html>
